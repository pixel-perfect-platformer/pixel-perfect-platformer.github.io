<!DOCTYPE html>
<html>

<head>
    <title>Platformer</title>
    <style>
        canvas {
            width: 45vw;
            height: 90vh;
            max-width: 45vw;
            max-height: 90vh;
            object-fit: contain;
            display: block;
            border: 1px solid black;
        }
        button {
            cursor: pointer;
        }
        button.pressed {
            transform: scale(0.98) translateY(2px);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        }
        /* Define the animation */
        @keyframes shake {
        0%, 100% { transform: scale(1) translateX(0); }
        12.5% { transform: scale(3) translateX(0); }
        25% { transform: scale(0.3) translateX(0); }
        37.5% { transform: scale(1) translateX(0); }
        50% { transform: scale(1) translateX(-50px); }
        62.5% { transform: scale(1) translateX(50px); }
        75% { transform: scale(1) translateX(-50px); }
        87.5% { transform: scale(1) translateX(50px); }
        }

        /* Class to trigger the animation */
        .animated {
        animation: shake 1s cubic-bezier(.36,.07,.19,.97) both;
        transition: none !important;
        }
        #startBtn.animated {
        transition: none !important;
        }
    </style>
</head>

<body>
    <div id="controls" style="margin-bottom:8px">
        <button id="startBtn" hidden>Start</button>
        <button id="editorBtn" hidden>Enter Editor</button>
        <button id="clearBtn">Clear Blocks</button>
        <button id="saveBtn" hidden>Save Level</button>
        <button id="loadBtn" hidden>Load Level</button>
        <select id="levelSelect"></select>
        <button id="newLevelBtn">New Level</button>
        <input id="levelNameInput" placeholder="Level name" style="width:120px;margin-left:6px" hidden />
        <button id="renameLevelBtn">Rename</button>
        <button id="deleteLevelBtn">Delete Level</button>
        <input id="textInput" placeholder="Text" style="width:120px;margin-left:6px" hidden />
        <button id="addTextBtn" hidden>Add Text</button>
        <label style="margin-left:8px">Block:</label>
        <select id="blockTypeSelect"><option value="solid">Solid</option><option value="end">End</option><option value="kill">Kill (Lava)</option></select>
        <button id="exportBtn">Export Code</button>
        <input id="importCode" placeholder="Paste code" style="width:180px" />
        <button id="importBtn">Import</button>
        <button id="nextLevelBtn">Next Level</button>
        <button id="restartBtn">Restart</button>
        <button id="toggleHitboxBtn" style="margin-left:8px">Show Hitboxes</button>
        <span id="editorHint" style="margin-left:12px;color:#333"></span>
        <div id="editorTools" style="display:none;margin-top:8px">
            <button id="buildModeBtn">Build</button>
            <button id="editModeBtn">Edit</button>
            <button id="deleteModeBtn">Delete</button>
        </div>
    </div>

    <canvas id="game"></canvas>
    <script>
        let upPressed = false;
        let leftPressed = false;
        let rightPressed = false;
            // Jump input buffering: `jumpBuffered` is true while ArrowUp is held.
            // `jumpUsed` prevents repeated jumps while the key remains held.
            let jumpBuffered = false;
            let jumpUsed = false;

        document.addEventListener('keydown', (e) => {
            if (e.code == 'ArrowUp' || e.code == 'KeyW' || e.code == 'Space') {
                upPressed = true;
                jumpBuffered = true;
                // If on title screen, Space starts the game
                if (showTitleScreen && e.code == 'Space') {
                    e.preventDefault();
                    showTitleScreen = false;
                    isRunning = true;
                    return;
                }
            } else if (e.code == 'ArrowLeft' || e.code == 'KeyA') {
                leftPressed = true;
            } else if (e.code == 'ArrowRight' || e.code == 'KeyD') {
                rightPressed = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code == 'ArrowUp' || e.code == 'KeyW' || e.code == 'Space') {
                upPressed = false;
                jumpBuffered = false;
                jumpUsed = false; // allow next press to jump
            } else if (e.code == 'ArrowLeft' || e.code == 'KeyA') {
                leftPressed = false;
            } else if (e.code == 'ArrowRight' || e.code == 'KeyD') {
                rightPressed = false;
            }
        });
        // Get canvas and ctx for drawing and stuff
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // UI elements
        const startBtn = document.getElementById('startBtn');
        const editorBtn = document.getElementById('editorBtn');
        const clearBtn = document.getElementById('clearBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const levelSelect = document.getElementById('levelSelect');
        const newLevelBtn = document.getElementById('newLevelBtn');
        const blockTypeSelect = document.getElementById('blockTypeSelect');
        const exportBtn = document.getElementById('exportBtn');
        const importCode = document.getElementById('importCode');
        const importBtn = document.getElementById('importBtn');
        const nextLevelBtn = document.getElementById('nextLevelBtn');
        const restartBtn = document.getElementById('restartBtn');
        const deleteLevelBtn = document.getElementById('deleteLevelBtn');
        const levelNameInput = document.getElementById('levelNameInput');
        const renameLevelBtn = document.getElementById('renameLevelBtn');
        const textInput = document.getElementById('textInput');
        const addTextBtn = document.getElementById('addTextBtn');
        const toggleHitboxBtn = document.getElementById('toggleHitboxBtn');
        const playerIconSelect = document.getElementById('playerIconSelect');
        const editorHint = document.getElementById('editorHint');

        function bindButtonAction(el, action) {
            if (!el) return;

            let pressed = false;

            const addPressed = (ev) => {
                pressed = true;
                el.classList.add('pressed');
                ev.preventDefault();
            };

            const clearPressed = () => {
                pressed = false;
                el.classList.remove('pressed');
            };

            const release = (ev) => {
                if (!pressed) return;          // only if it started on this button
                clearPressed();

                // Only trigger action if the pointer/touch ends still on the button
                const rect = el.getBoundingClientRect();
                const x = ev.changedTouches ? ev.changedTouches[0].clientX : ev.clientX;
                const y = ev.changedTouches ? ev.changedTouches[0].clientY : ev.clientY;

                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                try {
                    action(ev);
                } catch (e) {
                    console.error(e);
                }
                }
            };

            el.addEventListener('mousedown', addPressed);
            el.addEventListener('touchstart', addPressed, { passive: false });

            el.addEventListener('mouseup', release);
            el.addEventListener('touchend', release);

            el.addEventListener('mouseleave', clearPressed);
            el.addEventListener('touchcancel', clearPressed);
            }


        // Non-blocking status helper (replaces alerts)
        function showStatus(msg, ms = 1800) {
            if (editorHint) editorHint.textContent = msg;
            clearTimeout(showStatus._t);
            showStatus._t = setTimeout(() => { if (editorHint) editorHint.textContent = editorMode ? 'Editor: click to add/remove blocks' : ''; }, ms);
        }

        // Game/editor state
        let isRunning = false;
        let editorMode = false;
        let showTitleScreen = true;
        let showCustomizationScreen = false;
        let pressedTitleButton = null;
        let titleButtonIsDown = false;
        let currentPlayerColor = '#000000'; // default black
        let isAnimating = false;
        let animationStartTime = 0;
        const animationDuration = 1000; // 1 seconds
        let isTransitioning = false;
        let fadeOpacity = 1; // 1 for title screen, 0 for game screen
        let blocks = [];
        let texts = []; // placed text objects {x,y,text}
        let renderScale = 1;
        let levelCompleted = false;
        let showHitboxes = false;
        // Text dragging state
        let draggingTextIndex = -1;
        let dragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        // Painting state for click-drag block placement/removal
        let isPainting = false;
        let paintingMode = null; // 'add' or 'remove'
        // Editor mode: 'build', 'edit', 'delete'
        let editorToolMode = 'build';
        // Selected block for editing
        let selectedBlockIndex = -1;
        // Dragging block state
        let draggingBlockIndex = -1;
        let dragBlockOffsetX = 0;
        let dragBlockOffsetY = 0;
        // Levels: array of {name, blocks}
        let levels = [];
        let currentLevelIndex = 0;
        let currentBlockType = 'solid';
        let currentPlayerIcon = 'square';

        // Maintain 500x500 logical size but scale to fullscreen
        const SCREEN_WIDTH = 500;
        const SCREEN_HEIGHT = 500;

        // Scale factors for fullscreen
        let scaleX = 0.5;
        let scaleY = 0.5;

        function resizeCanvas() {
            // Get display size
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;

            // Calculate scale for x and y separately to fill the canvas
            scaleX = displayWidth / SCREEN_WIDTH;
            scaleY = displayHeight / SCREEN_HEIGHT;
            renderScale = Math.min(scaleX, scaleY);

            // Set canvas resolution to exact display size for crisp rendering
            canvas.width = displayWidth;
            canvas.height = displayHeight;

            // Reset transform and set scale to fill the canvas
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(scaleX, scaleY);

            // Center the game world if needed
            ctx.translate((SCREEN_WIDTH - SCREEN_WIDTH) / 2, (SCREEN_HEIGHT - SCREEN_HEIGHT) / 2);
        }

        // Initial resize
        resizeCanvas();
        const WHITE = '#FFFFFF';
        const BLACK = '#000000'


        let player = null;
        const keys = {};

        class Player {
            constructor() {
                this.width = 5;
                this.height = 5;
                // Start centered horizontally and standing on the ground
                this.x = Math.floor(SCREEN_WIDTH / 2) - Math.floor(this.width / 2);
                this.y = SCREEN_HEIGHT - this.height;
                this.lateral_speed = 0.0;
                this.vertical_speed = 0.0;
                this.accel = 0.5;
                this.friction = 0.85;
                this.max_speed = 12;
                this.gravity = 0.8;
                this.onGround = false;
            }

            update() {
                const wasOnGround = this.onGround;

                    // Horizontal input affects lateral speed
                    if (leftPressed) this.lateral_speed -= this.accel;
                    if (rightPressed) this.lateral_speed += this.accel;

                    // Clamp lateral speed and apply friction later
                    this.lateral_speed = Math.max(-this.max_speed, Math.min(this.lateral_speed, this.max_speed));

                    // --- Horizontal move + collision resolution (separate axis) ---
                    const oldX = this.x, oldY = this.y;
                    let newX = this.x + this.lateral_speed;
                    for (let b of blocks) {
                        // horizontal swept check: does horizontal move cause overlap with block while vertically overlapping
                        if (this.y < b.y + b.height && this.y + this.height > b.y) {
                            if (newX < b.x + b.width && newX + this.width > b.x) {
                                if (this.lateral_speed > 0) newX = b.x - this.width;
                                else if (this.lateral_speed < 0) newX = b.x + b.width;
                                this.lateral_speed = 0;
                            }
                        }
                    }
                    this.x = newX;

                    // Apply gravity to vertical speed
                    this.vertical_speed += this.gravity;

                    // --- Vertical move + swept collision resolution ---
                    let newY = this.y + this.vertical_speed;
                    let landed = false;
                    for (let b of blocks) {
                        // horizontal overlap at any point during move? check current x against block
                        if (this.x < b.x + b.width && this.x + this.width > b.x) {
                            // falling onto block (crossing its top between oldY and newY)
                            if (oldY + this.height <= b.y && newY + this.height >= b.y && this.vertical_speed > 0) {
                                newY = b.y - this.height;
                                this.vertical_speed = 0;
                                landed = true;
                            }
                            // hitting head on block (crossing its bottom)
                            else if (oldY >= b.y + b.height && newY <= b.y + b.height && this.vertical_speed < 0) {
                                newY = b.y + b.height;
                                this.vertical_speed = 0;
                            }
                        }
                        // If block is an end block, also check swept intersection between old and new positions (broad phase)
                        // end block swept check
                        if ((b.type === 'end' || b.end === true) && !levelCompleted) {
                            const sweepTop = Math.min(oldY, newY);
                            const sweepBottom = Math.max(oldY + this.height, newY + this.height);
                            const vertOverlap = sweepBottom >= b.y && sweepTop <= b.y + b.height;
                            const sweepLeft = Math.min(oldX, newX);
                            const sweepRight = Math.max(oldX + this.width, newX + this.width);
                            const horizOverlap = (Math.min(sweepRight, b.x + b.width) >= Math.max(sweepLeft, b.x));
                            if (vertOverlap && horizOverlap) {
                                levelCompleted = true;
                                onLevelComplete();
                            }
                        }
                        // kill block swept check (player dies)
                        if ((b.type === 'kill' || b.kill === true)) {
                            const sweepTopK = Math.min(oldY, newY);
                            const sweepBottomK = Math.max(oldY + this.height, newY + this.height);
                            const vertOverlapK = sweepBottomK >= b.y && sweepTopK <= b.y + b.height;
                            const sweepLeftK = Math.min(oldX, newX);
                            const sweepRightK = Math.max(oldX + this.width, newX + this.width);
                            const horizOverlapK = (Math.min(sweepRightK, b.x + b.width) >= Math.max(sweepLeftK, b.x));
                            if (vertOverlapK && horizOverlapK) {
                                onPlayerKilled();
                            }
                        }
                        // Start can only be on ground
                        
                    }

                    // Floor collision (prevent entering gray box)
                    if (newY + this.height > SCREEN_HEIGHT - 50) {
                        newY = SCREEN_HEIGHT - 50 - this.height;
                        this.vertical_speed = 0;
                        landed = true;
                    }
                    if (newY < 0) {
                        newY = 0;
                        this.vertical_speed = 0;
                    }

                    this.y = newY;
                    this.onGround = landed;

                    // Reset jumpUsed when landing, so next press-hold can jump
                    if (landed) jumpUsed = false;

                    // If player is holding jump and the player's Y is not changing (stable),
                    // trigger a jump (buffered). Prevent repeated jumps while the key remains held.
                    const yDelta = Math.abs(newY - oldY);
                    if (jumpBuffered && !jumpUsed && yDelta === 0) {
                        this.vertical_speed = -10;
                        jumpUsed = true;
                        this.onGround = false;
                    }

                    // Apply friction: reduce lateral speed when no input
                    const frictionFactor = (leftPressed || rightPressed) ? 0.95 : this.friction;
                    this.lateral_speed *= frictionFactor;
                // Physics
                // Stop micro-coasting
                if (Math.abs(this.lateral_speed) < 0.1) this.lateral_speed = 0;
                if (Math.abs(this.vertical_speed) < 0.1) this.vertical_speed = 0;

                // Clamp boundaries (x and y already mostly handled by collision resolution)
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > SCREEN_WIDTH) this.x = SCREEN_WIDTH - this.width;
                if (this.y < 0) {
                    this.y = 0;
                    this.vertical_speed = 0;
                }
                if (this.y + this.height > SCREEN_HEIGHT) {
                    this.y = SCREEN_HEIGHT - this.height;
                    this.vertical_speed = 0;
                    this.onGround = true;
                }
                return true;
            }

            draw(ctx) {
                ctx.fillStyle = currentPlayerColor;
                if (currentPlayerIcon === 'circle') {
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (currentPlayerIcon === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x, this.y + this.height);
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // default square
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 1;
                if (currentPlayerIcon === 'circle') {
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (currentPlayerIcon === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x, this.y + this.height);
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                }
                if (showHitboxes) {
                    ctx.save();
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                    ctx.restore();
                }
            }
            get rect() {
                return { x: this.x, y: this.y, width: this.width, height: this.height };
            }
        }

        function gameLoop(time) {
            resizeCanvas()
            // Clear screen
            ctx.fillStyle = WHITE;
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            // Show/hide title controls
            const titleControls = document.getElementById('titleControls');
            if (titleControls) titleControls.style.display = showTitleScreen ? 'block' : 'none';

            if (isTransitioning) {
                const progress = Math.min((Date.now() - animationStartTime) / animationDuration, 1);
                const titleOpacity = 1 - progress;
                const gameOpacity = progress;

                // Draw title screen with fading out
                ctx.save();
                ctx.globalAlpha = titleOpacity;
                drawTitleScreen(ctx);
                ctx.restore();

                // Draw game screen with fading in
                ctx.save();
                ctx.globalAlpha = gameOpacity;
                drawBlocks(ctx);
                if (!editorMode && isRunning) {
                    player.draw(ctx);
                }
                drawHUD(ctx);
                ctx.restore();

                if (progress >= 1) {
                    isTransitioning = false;
                    showTitleScreen = false;
                    isRunning = true;
                }
            } else if (showTitleScreen) {
                drawTitleScreen(ctx);
                requestAnimationFrame(gameLoop);
                return;
            } else if (showCustomizationScreen) {
                drawCustomizationScreen(ctx);
                requestAnimationFrame(gameLoop);
                return;
            } else {
                // Draw blocks
                drawBlocks(ctx);

                // Player exists and is active only when NOT in editor mode
                if (!editorMode) {
                    if (isRunning) {
                        player.update();
                    }
                    player.draw(ctx);
                }

                // Frame-level check for touching an end block (robust against missed checks)
                if (isRunning && !levelCompleted) {
                    for (let b of blocks) {
                        if ((b.type === 'end' || b.end === true) && player.x <= b.x + b.width && player.x + player.width >= b.x && player.y <= b.y + b.height && player.y + player.height >= b.y) {
                            levelCompleted = true;
                            onLevelComplete();
                            break;
                        }
                        if ((b.type === 'kill' || b.kill === true) && player.x <= b.x + b.width && player.x + player.width >= b.x && player.y <= b.y + b.height && player.y + player.height >= b.y) {
                            onPlayerKilled();
                            break;
                        }
                    }
                }

                // Draw editor HUD
                drawHUD(ctx);
            }
            requestAnimationFrame(gameLoop)
        }
        player = new Player()
        loadLevelsFromStorage();
        requestAnimationFrame(gameLoop)

        // --- Editor & UI functions ---
        // Helper: draw rounded rectangle path (doesnot fill/stroke)
        function roundRectPath(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }
        function drawTitleScreen(ctx) {
            if (isAnimating) {
                const progress = Math.min((Date.now() - animationStartTime) / animationDuration, 1);
                if (progress >= 1) {
                    isAnimating = false;
                    showTitleScreen = false;
                    isRunning = true;
                    fadeOpacity = 1;
                    return;
                }
                if (progress > 0.75) {
                    fadeOpacity = (progress - 0.75) / 0.25; // 0 to 1
                    ctx.globalAlpha = 1 - fadeOpacity;
                }
            }

            // Gradient background (purple to blue)
            const gradient = ctx.createLinearGradient(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            gradient.addColorStop(0, '#1a0033');
            gradient.addColorStop(0.5, '#330066');
            gradient.addColorStop(1, '#004d99');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            // Animated geometric background elements
            const time = Date.now() * 0.001;

            // Floating circles
            ctx.fillStyle = 'rgba(255, 100, 0, 0.15)';
            ctx.beginPath();
            ctx.arc(100 + Math.sin(time) * 20, 100 + Math.cos(time * 0.7) * 30, 40, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(0, 200, 255, 0.1)';
            ctx.beginPath();
            ctx.arc(400 + Math.cos(time * 1.3) * 25, 80 + Math.sin(time * 0.9) * 35, 60, 0, Math.PI * 2);
            ctx.fill();

            // Title
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PLATFORMER', SCREEN_WIDTH / 2, 120);

            // Play button (orange circle with play icon)
            const playX = SCREEN_WIDTH / 2 - 80;
            const playY = SCREEN_HEIGHT / 2 - 30;
            const playRadius = 45;

            ctx.save();
            if (isAnimating) {
                const progress = Math.min((Date.now() - animationStartTime) / animationDuration, 1);
                let scale = 1;
                let shakeOffset = 0;
                if (progress < 0.25) {
                    const p = progress / 0.25;
                    if (p < 0.5) {
                        scale = 1 + p * 1; // 1 to 1.5
                    } else {
                        scale = 1.5 - (p - 0.5) * 2; // 1.5 to 0.5
                    }
                } else if (progress < 0.5) {
                    shakeOffset = Math.sin((progress - 0.25) * 40) * 5;
                }
                ctx.translate(playX, playY);
                ctx.scale(scale, scale);
                ctx.translate(-playX, -playY);
                ctx.translate(shakeOffset, 0);
            }

            // Button glow
            ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(playX, playY, playRadius + 15, 0, Math.PI * 2);
            ctx.fill();

            // Button
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.arc(playX, playY, playRadius, 0, Math.PI * 2);
            ctx.fill();

            // Play triangle icon
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(playX - 12, playY - 18);
            ctx.lineTo(playX - 12, playY + 18);
            ctx.lineTo(playX + 20, playY);
            ctx.closePath();
            ctx.fill();

            ctx.restore();

            // Editor button (cyan circle with pencil icon)
            const editorX = SCREEN_WIDTH / 2 + 80;
            const editorY = SCREEN_HEIGHT / 2 - 30;
            const editorRadius = 45;

            // Button glow
            ctx.fillStyle = 'rgba(0, 200, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(editorX, editorY, editorRadius + 15, 0, Math.PI * 2);
            ctx.fill();

            // Button
            ctx.fillStyle = '#00ccff';
            ctx.beginPath();
            ctx.arc(editorX, editorY, editorRadius, 0, Math.PI * 2);
            ctx.fill();

            // Editor icon — stack of bricks (explicit rows 3,2,3,2,3)
            const brickCols = [3, 2, 3, 2, 3];
            const rows = brickCols.length;
            const brickW = 18;
            const brickH = 10;
            const gap = 3;
            const totalH = rows * brickH + (rows - 1) * gap;
            const topY = editorY - Math.floor(totalH / 2);

            ctx.lineWidth = 3;
            for (let r = 0; r < rows; r++) {
                const cols = brickCols[r];
                const rowW = cols * brickW + (cols - 1) * gap;
                const y = topY + r * (brickH + gap);
                const startX = editorX - rowW / 2;

                // mortar/glue behind the row (fills horizontal gaps and between bricks)
                ctx.save();
                ctx.fillStyle = '#d9d9d9';
                roundRectPath(ctx, startX - gap / 2, y - gap / 2, rowW + gap, brickH + gap, 3);
                ctx.fill();
                ctx.restore();

                for (let c = 0; c < cols; c++) {
                    const x = startX + c * (brickW + gap);
                    // brick shadow + fill
                    ctx.save();
                    ctx.shadowColor = 'rgba(0,0,0,0.55)';
                    ctx.shadowBlur = 12;
                    ctx.shadowOffsetY = 3;

                    ctx.fillStyle = '#c0392b';
                    ctx.strokeStyle = '#050505';
                    roundRectPath(ctx, x, y, brickW, brickH, 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();

                    // small highlight rectangle (no shadow)
                    ctx.fillStyle = '#ffd3c2';
                    ctx.fillRect(x + 3, y + 2, brickW - 6, brickH - 5);
                }
            }

            // Customize button (green circle with gear icon)
            const customizeX = SCREEN_WIDTH / 2;
            const customizeY = SCREEN_HEIGHT / 2 + 50;
            const customizeRadius = 35;

            // Button glow
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(customizeX, customizeY, customizeRadius + 10, 0, Math.PI * 2);
            ctx.fill();

            // Button
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(customizeX, customizeY, customizeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Gear icon (simple)
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('⚙', customizeX, customizeY + 7);

            ctx.globalAlpha = 1; // reset
        }

        function drawCustomizationScreen(ctx) {
            // Background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            // Title
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Choose Player Color', SCREEN_WIDTH / 2, 80);

            // Color options
            const colors = [
                { name: 'Black', color: '#000000' },
                { name: 'Red', color: '#ff0000' },
                { name: 'Blue', color: '#0000ff' },
                { name: 'Green', color: '#00ff00' },
                { name: 'Yellow', color: '#ffff00' },
                { name: 'Purple', color: '#800080' },
                { name: 'Orange', color: '#ffa500' },
                { name: 'Pink', color: '#ffc0cb' }
            ];

            const buttonWidth = 60;
            const buttonHeight = 30;
            const spacing = 10;
            const colorsPerRow = 4;
            const startX = (SCREEN_WIDTH - (colorsPerRow * (buttonWidth + spacing) - spacing)) / 2;
            const startY = 120;
            const rowSpacing = 50;

            for (let i = 0; i < colors.length; i++) {
                const row = Math.floor(i / colorsPerRow);
                const col = i % colorsPerRow;
                const x = startX + col * (buttonWidth + spacing);
                const y = startY + row * rowSpacing;

                // Button background
                ctx.fillStyle = colors[i].color;
                ctx.fillRect(x, y, buttonWidth, buttonHeight);

                // Button border
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, buttonWidth, buttonHeight);

                // Text
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(colors[i].name, x + buttonWidth / 2, y + buttonHeight / 2 + 3);
            }

            // Back button
            const backX = SCREEN_WIDTH / 2 - 50;
            const backY = SCREEN_HEIGHT - 80;
            const backWidth = 100;
            const backHeight = 40;

            ctx.fillStyle = '#cccccc';
            ctx.fillRect(backX, backY, backWidth, backHeight);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeRect(backX, backY, backWidth, backHeight);

            ctx.fillStyle = '#000000';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Back', backX + backWidth / 2, backY + backHeight / 2 + 5);

            ctx.globalAlpha = 1; // reset
        }

        // Click detection for title screen buttons
        function getTitleScreenButtonAtPos(x, y) {
            // Play button (left)
            const playX = SCREEN_WIDTH / 2 - 80;
            const playY = SCREEN_HEIGHT / 2 - 30;
            const playRadius = 45;
            const playDist = Math.sqrt((x - playX) ** 2 + (y - playY) ** 2);
            if (playDist <= playRadius) return 'play';

            // Editor button (right)
            const editorX = SCREEN_WIDTH / 2 + 80;
            const editorY = SCREEN_HEIGHT / 2 - 30;
            const editorRadius = 45;
            const editorDist = Math.sqrt((x - editorX) ** 2 + (y - editorY) ** 2);
            if (editorDist <= editorRadius) return 'editor';

            // Customize button (center bottom)
            const customizeX = SCREEN_WIDTH / 2;
            const customizeY = SCREEN_HEIGHT / 2 + 50;
            const customizeRadius = 35;
            const customizeDist = Math.sqrt((x - customizeX) ** 2 + (y - customizeY) ** 2);
            if (customizeDist <= customizeRadius) return 'customize';

            return null;
        }
        
        function drawBlocks(ctx) {
            // Draw gray bottom bar
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, SCREEN_HEIGHT - 50, SCREEN_WIDTH, 50);

            for (let i = 0; i < blocks.length; i++) {
                const b = blocks[i];
                if (b.type === 'end') ctx.fillStyle = 'green';
                else if (b.type === 'kill') ctx.fillStyle = '#ff4500';
                else if (b.type === 'start') ctx.fillStyle = '#1e90ff';
                else ctx.fillStyle = '#666';
                ctx.fillRect(b.x, b.y, b.width, b.height);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(b.x, b.y, b.width, b.height);
                if (showHitboxes) {
                    ctx.save();
                    ctx.strokeStyle = 'magenta';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(b.x, b.y, b.width, b.height);
                    ctx.restore();
                }
                // Highlight selected block
                if (selectedBlockIndex === i) {
                    ctx.save();
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(b.x - 2, b.y - 2, b.width + 4, b.height + 4);
                    ctx.restore();
                }
            }
            // draw texts
            ctx.fillStyle = '#000';
            ctx.font = '12px sans-serif';
            for (let t of texts) {
                ctx.fillText(t.text, t.x, t.y);
            }
                // draw selection for dragging
                if (dragging && draggingTextIndex >= 0 && texts[draggingTextIndex]) {
                    const sel = texts[draggingTextIndex];
                    ctx.save();
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 1;
                    ctx.font = '12px sans-serif';
                    const w = ctx.measureText(sel.text).width;
                    const h = 12;
                    ctx.strokeRect(sel.x, sel.y - h, w, h);
                    ctx.restore();
                }
        }

        function drawHUD(ctx) {
            // Draw back arrow (visible when not on title screen) so user can return
            function drawBackArrow(ctx) {
                const bx = 12, by = 8, bw = 40, bh = 28, br = 6;
                ctx.save();
                ctx.shadowColor = 'rgba(0,0,0,0.45)';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#19a819';
                roundRectPath(ctx, bx, by, bw, bh, br);
                ctx.fill();
                ctx.restore();
                // arrow triangle
                ctx.fillStyle = '#e8ffe8';
                ctx.beginPath();
                ctx.moveTo(bx + 10, by + bh / 2);
                ctx.lineTo(bx + bw - 10, by + 6);
                ctx.lineTo(bx + bw - 10, by + bh - 6);
                ctx.closePath();
                ctx.fill();
            }

            function isBackArrowAtPos(x, y) {
                const bx = 12, by = 8, bw = 40, bh = 28;
                return x >= bx && x <= bx + bw && y >= by && y <= by + bh;
            }
            if (!showTitleScreen) {
                drawBackArrow(ctx);
            }

            if (editorMode) {
                // Editor toolbar at top
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(60, 0, SCREEN_WIDTH, 35);
                
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 13px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('EDITOR', 60, 22);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.fillText('Block: ' + currentBlockType, 110, 22);
                
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '11px Arial';
                ctx.fillText('Click to paint | Double-click text to edit | Drag text to move', 180, 15);
                ctx.fillText('Right click to add a text box', 180, 28);
                return;
            }
            
            if (!isRunning) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                startBtn.style.display = 'block';
                startBtn.style.fontSize = '24px';
                startBtn.style.padding = '10px 20px';
                startBtn.style.position = 'absolute';
                startBtn.style.left = '50%';
                startBtn.style.top = '50%';
                startBtn.style.transform = 'translate(-50%, -50%)';
                startBtn.textContent = 'Start';
            } else {
                startBtn.style.display = 'none';
            }
            if (levelCompleted) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, SCREEN_HEIGHT/2 - 30, SCREEN_WIDTH, 60);
                ctx.fillStyle = '#0f0';
                ctx.font = '24px sans-serif';
                ctx.fillText('You have completed the level!', 20, SCREEN_HEIGHT/2 + 8);
                
            }
            if (editorMode) {
                editorHint.textContent = 'Editor: click to add/remove blocks (grid 10px)';
            } else {
                editorHint.textContent = '';
            }
        }

        // expose helper for click handling
        window._isBackArrowAtPos = function(x, y) { return (function(x,y){ const bx=12,by=8,bw=40,bh=28; return x>=bx && x<=bx+bw && y>=by && y<=by+bh; })(x,y); };

        function canvasToGameCoords(evt) {
            const rect = canvas.getBoundingClientRect();
            const x = (evt.clientX - rect.left) / scaleX;
            const y = (evt.clientY - rect.top) / scaleY;
            return { x, y };
        }

        // Return index of text at position or -1
        function findTextAt(x, y) {
            ctx.font = '12px sans-serif';
            for (let i = texts.length - 1; i >= 0; i--) {
                const t = texts[i];
                const metrics = ctx.measureText(t.text);
                const w = metrics.width;
                const h = 12; // approximate font height
                const left = t.x;
                const top = t.y - h; // text drawn at baseline
                if (x >= left && x <= left + w && y >= top && y <= top + h) return i;
            }
            return -1;
        }

        function addBlockAt(x, y) {
            const grid = 10;
            const bw = 40, bh = 10;
            const gx = Math.floor(x / grid) * grid;
            const gy = Math.floor(y / grid) * grid;
            // If placing a start block, ensure only one exists per level
            if (currentBlockType === 'start') {
                for (let i = blocks.length - 1; i >= 0; i--) {
                    if (blocks[i].type === 'start') blocks.splice(i, 1);
                }
            }
            blocks.push({ x: gx, y: gy, width: bw, height: bh, type: currentBlockType });
        }

        // Add text at grid position
        function addTextAt(x, y, text) {
            const grid = 10;
            const gx = Math.floor(x / grid) * grid;
            const gy = Math.floor(y / grid) * grid;
            texts.push({ x: gx, y: gy, text: text });
        }

        function removeBlockAt(x, y) {
            for (let i = blocks.length - 1; i >= 0; i--) {
                const b = blocks[i];
                if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                    blocks.splice(i, 1);
                    return;
                }
            }
        }

        // Editor mouse interactions: support placing text, toggling/painting blocks, and dragging texts
        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // Only handle left-click for blocks
            const p = canvasToGameCoords(e);
            // If on title screen, check which button was clicked
            if (showTitleScreen) {
                const btn = getTitleScreenButtonAtPos(p.x, p.y);
                if (btn) {
                    // record which button was pressed; actual action happens on release
                    pressedTitleButton = btn;
                    titleButtonIsDown = true;
                }
                return;
            }

        // Back arrow (top-left) should always return to title screen when clicked
            if (window._isBackArrowAtPos && window._isBackArrowAtPos(p.x, p.y)) {
                showTitleScreen = true;
                showCustomizationScreen = false;
                editorMode = false;
                isRunning = false;
                editorBtn.textContent = 'Enter Editor';
                isPainting = false;
                dragging = false;
                draggingTextIndex = -1;
                return;
            }

            if (!editorMode) return;
            const txt = (textInput && textInput.value || '').trim();
            // If user has typed text, place it at click
            if (txt) {
                addTextAt(p.x, p.y, txt);
                textInput.value = '';
                saveCurrentLevel();
                return;
            }
            // If clicked on an existing text, start dragging it
            const ti = findTextAt(p.x, p.y);
            if (ti >= 0) {
                draggingTextIndex = ti;
                dragging = true;
                const t = texts[ti];
                dragOffsetX = p.x - t.x;
                dragOffsetY = p.y - t.y;
                return;
            }

            // Check if clicked on a block
            let clickedBlockIndex = -1;
            for (let i = 0; i < blocks.length; i++) {
                const b = blocks[i];
                if (p.x >= b.x && p.x <= b.x + b.width && p.y >= b.y && p.y <= b.y + b.height) {
                    clickedBlockIndex = i;
                    break;
                }
            }

            if (clickedBlockIndex >= 0) {
                if (editorToolMode === 'delete') {
                    // Delete the block
                    blocks.splice(clickedBlockIndex, 1);
                    saveCurrentLevel();
                    return;
                } else if (editorToolMode === 'edit') {
                    // Select and start dragging the block
                    selectedBlockIndex = clickedBlockIndex;
                    draggingBlockIndex = clickedBlockIndex;
                    const b = blocks[clickedBlockIndex];
                    dragBlockOffsetX = p.x - b.x;
                    dragBlockOffsetY = p.y - b.y;
                    return;
                } else if (editorToolMode === 'build') {
                    // Toggle block (remove if exists)
                    blocks.splice(clickedBlockIndex, 1);
                    saveCurrentLevel();
                    return;
                }
            } else {
                // Clicked on empty space
                if (editorToolMode === 'build') {
                    // Add block
                    addBlockAt(p.x, p.y);
                    saveCurrentLevel();
                    return;
                } else if (editorToolMode === 'edit') {
                    // Deselect
                    selectedBlockIndex = -1;
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!editorMode) return;
            const p = canvasToGameCoords(e);
            // If dragging a text, move it
            if (dragging && draggingTextIndex >= 0) {
                const grid = 10;
                const nx = Math.floor((p.x - dragOffsetX) / grid) * grid;
                const ny = Math.floor((p.y - dragOffsetY) / grid) * grid;
                texts[draggingTextIndex].x = nx;
                texts[draggingTextIndex].y = ny + 12; // keep baseline offset
                return;
            }
            // If painting mode (mouse held down after toggling), apply add/remove along path
            if (isPainting && paintingMode) {
                const grid = 10;
                const gx = Math.floor(p.x / grid) * grid;
                const gy = Math.floor(p.y / grid) * grid;
                // remove mode: remove any block at this grid cell
                if (paintingMode === 'remove') {
                    for (let i = blocks.length - 1; i >= 0; i--) {
                        const b = blocks[i];
                        if (b.x === gx && b.y === gy) {
                            blocks.splice(i, 1);
                            break;
                        }
                    }
                } else if (paintingMode === 'add') {
                    // add mode: add block if not present
                    let exists = false;
                    for (let b of blocks) {
                        if (b.x === gx && b.y === gy) { exists = true; break; }
                    }
                    if (!exists) addBlockAt(gx + 1, gy + 1);
                }
            }
        });

        // Handle mouseup for canvas: trigger title-screen actions on release
        canvas.addEventListener('mouseup', (e) => {
            const p = canvasToGameCoords(e);
            if (pressedTitleButton) {
                const btn = getTitleScreenButtonAtPos(p.x, p.y);
                if (btn === pressedTitleButton) {
                    if (btn === 'play' && !isAnimating) {
                        isAnimating = true;
                        animationStartTime = Date.now();
                    }
                    else if (btn === 'editor') { showTitleScreen = false; editorMode = true; editorBtn.textContent = 'Exit Editor'; }
                    else if (btn === 'customize') { showTitleScreen = false; showCustomizationScreen = true; }
                }
                pressedTitleButton = null;
                titleButtonIsDown = false;
                return;
            }

            // Handle customization screen clicks
            if (showCustomizationScreen) {
                const colors = [
                    { name: 'Black', color: '#000000' },
                    { name: 'Red', color: '#ff0000' },
                    { name: 'Blue', color: '#0000ff' },
                    { name: 'Green', color: '#00ff00' },
                    { name: 'Yellow', color: '#ffff00' },
                    { name: 'Purple', color: '#800080' },
                    { name: 'Orange', color: '#ffa500' },
                    { name: 'Pink', color: '#ffc0cb' }
                ];

                const buttonWidth = 60;
                const buttonHeight = 30;
                const spacing = 10;
                const colorsPerRow = 4;
                const startX = (SCREEN_WIDTH - (colorsPerRow * (buttonWidth + spacing) - spacing)) / 2;
                const startY = 120;
                const rowSpacing = 50;

                // Check color buttons
                for (let i = 0; i < colors.length; i++) {
                    const row = Math.floor(i / colorsPerRow);
                    const col = i % colorsPerRow;
                    const x = startX + col * (buttonWidth + spacing);
                    const y = startY + row * rowSpacing;
                    if (p.x >= x && p.x <= x + buttonWidth && p.y >= y && p.y <= y + buttonHeight) {
                        currentPlayerColor = colors[i].color;
                        showCustomizationScreen = false;
                        showTitleScreen = true;
                        return;
                    }
                }

                // Check back button
                const backX = SCREEN_WIDTH / 2 - 50;
                const backY = SCREEN_HEIGHT - 80;
                const backWidth = 100;
                const backHeight = 40;
                if (p.x >= backX && p.x <= backX + backWidth && p.y >= backY && p.y <= backY + backHeight) {
                    showCustomizationScreen = false;
                    showTitleScreen = true;
                }
                return;
            }
        });

        // touch support: treat touchstart like mousedown and touchend like mouseup
        canvas.addEventListener('touchstart', (e) => { const p = canvasToGameCoords(e.touches[0]); if (showTitleScreen) { const btn = getTitleScreenButtonAtPos(p.x,p.y); if (btn) pressedTitleButton = btn; } }, {passive:false});
        canvas.addEventListener('touchend', (e) => { if (!pressedTitleButton) return; const touch = (e.changedTouches && e.changedTouches[0]); if (!touch) { pressedTitleButton = null; return; } const p = canvasToGameCoords(touch); const btn = getTitleScreenButtonAtPos(p.x,p.y); if (btn === pressedTitleButton) { if (btn === 'play') { showTitleScreen = false; isRunning = true; } else if (btn === 'editor') { showTitleScreen = false; editorMode = true; editorBtn.textContent = 'Exit Editor'; } } pressedTitleButton = null; }, {passive:false});

        canvas.addEventListener('mouseup', (e) => {
            if (!editorMode) return;
            // finish painting if active
            if (isPainting) {
                isPainting = false;
                paintingMode = null;
                saveCurrentLevel();
            }
            if (dragging && draggingTextIndex >= 0) {
                dragging = false;
                draggingTextIndex = -1;
                saveCurrentLevel();
            }
        });

        // Right-click to add text box
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (!editorMode) return;
            const p = canvasToGameCoords(e);
            const text = prompt('Enter text:');
            if (text) {
                addTextAt(p.x, p.y, text);
                saveCurrentLevel();
            }
        });

        // Double-click a placed text to edit or remove it
        canvas.addEventListener('dblclick', (e) => {
            if (!editorMode) return;
            const p = canvasToGameCoords(e);
            const ti = findTextAt(p.x, p.y);
            if (ti < 0) return;
            const current = texts[ti].text;
            const edited = prompt('Edit text (leave empty to delete):', current);
            if (edited === null) return; // cancelled
            const trimmed = (edited || '').trim();
            if (trimmed === '') {
                texts.splice(ti, 1);
            } else {
                texts[ti].text = trimmed;
            }
            saveCurrentLevel();
        });

        // Block type selector
        blockTypeSelect.addEventListener('change', (e) => {
            currentBlockType = e.target.value;
        });

        // Player icon selector
        playerIconSelect.addEventListener('change', (e) => {
            currentPlayerIcon = e.target.value;
        });

        // Level management
        function saveLevelsToStorage() {
            try { localStorage.setItem('platformer_levels', JSON.stringify(levels)); } catch (e) {}
        }

        function loadLevelsFromStorage() {
            const data = localStorage.getItem('platformer_levels');
            if (data) {
                try { levels = JSON.parse(data); } catch (e) { levels = []; }
            }
            if (!levels || levels.length === 0) {
                levels = [{ name: 'Level 1', blocks: [], texts: [] }];
            }
            populateLevelSelect();
            loadLevel(0);
        }

        function populateLevelSelect() {
            levelSelect.innerHTML = '';
            levels.forEach((lv, i) => {
                const opt = document.createElement('option');
                opt.value = i; opt.textContent = lv.name || ('Level ' + (i+1));
                levelSelect.appendChild(opt);
            });
            levelSelect.value = currentLevelIndex;
        }

        function loadLevel(index) {
            currentLevelIndex = index;
            blocks = JSON.parse(JSON.stringify(levels[index].blocks || []));
            texts = JSON.parse(JSON.stringify(levels[index].texts || []));
            // Check for start blocks and remove them with alert
            const startBlocks = blocks.filter(b => b.type === 'start');
            if (startBlocks.length > 0) {
                alert('Compatibility issue: This level contains start blocks which are no longer supported. They will be removed.');
                blocks = blocks.filter(b => b.type !== 'start');
                // Save the updated level
                levels[index].blocks = JSON.parse(JSON.stringify(blocks));
                saveLevelsToStorage();
            }
            // Always start at bottom left corner, but position on top of any block there
            player.x = 0;
            player.y = SCREEN_HEIGHT - player.height;
            // Check for block at spawn location and position player on top
            for (let b of blocks) {
                if (b.x <= player.x && b.x + b.width > player.x && b.y <= player.y + player.height && b.y + b.height > player.y) {
                    player.y = b.y - player.height;
                    break;
                }
            }
            player.lateral_speed = player.vertical_speed = 0;
            isRunning = false;
            levelCompleted = false;
            // populate level name input
            if (levelNameInput) levelNameInput.value = levels[index].name || ('Level ' + (index+1));
        }

        function saveCurrentLevel() {
            // Ensure current level slot exists
            if (!levels[currentLevelIndex]) levels[currentLevelIndex] = { name: 'Level ' + (currentLevelIndex+1), blocks: [], texts: [] };
            levels[currentLevelIndex].blocks = JSON.parse(JSON.stringify(blocks));
            levels[currentLevelIndex].texts = JSON.parse(JSON.stringify(texts));
            saveLevelsToStorage();
            populateLevelSelect();
            showStatus('Level saved to collection');
        }

        function newLevel() {
            levels.push({ name: 'Level ' + (levels.length+1), blocks: [], texts: [] });
            currentLevelIndex = levels.length-1;
            populateLevelSelect();
            loadLevel(currentLevelIndex);
            saveLevelsToStorage();
        }

        function exportLevelCode() {
            const payload = { name: levels[currentLevelIndex].name, blocks: blocks, texts: texts };
            const code = btoa(JSON.stringify(payload));
            return code;
        }

        function importLevelCode(code) {
            try {
                const payload = JSON.parse(atob(code));
                levels.push({ name: payload.name || ('Imported ' + (levels.length+1)), blocks: payload.blocks || [], texts: payload.texts || [] });
                saveLevelsToStorage();
                populateLevelSelect();
                loadLevel(levels.length-1);
                showStatus('Imported level');
            } catch (e) { showStatus('Invalid code'); }
        }

        // wire up level UI
        levelSelect.addEventListener('change', (e) => { loadLevel(parseInt(e.target.value)); });
        bindButtonAction(newLevelBtn, newLevel);
        bindButtonAction(deleteLevelBtn, () => {
            if (!confirm('Delete current level? This cannot be undone.')) return;
            // remove current
            levels.splice(currentLevelIndex, 1);
            if (levels.length === 0) {
                levels = [{ name: 'Level 1', blocks: [] }];
                currentLevelIndex = 0;
            } else if (currentLevelIndex >= levels.length) {
                currentLevelIndex = levels.length - 1;
            }
            saveLevelsToStorage();
            populateLevelSelect();
            loadLevel(currentLevelIndex);
        });
        bindButtonAction(renameLevelBtn, () => {
            const name = (levelNameInput.value || '').trim() || ('Level ' + (currentLevelIndex+1));
            levels[currentLevelIndex].name = name;
            saveLevelsToStorage();
            populateLevelSelect();
            levelSelect.value = currentLevelIndex;
            showStatus('Level renamed');
        });
        bindButtonAction(exportBtn, () => { const code = exportLevelCode(); prompt('Level code (copy):', code); });
        bindButtonAction(importBtn, () => { const c = importCode.value.trim(); if (c) importLevelCode(c); });

        // Add Text button places text near player
        bindButtonAction(addTextBtn, () => {
            if (!editorMode) { showStatus('Enter Editor to add text'); return; }
            const val = (textInput && textInput.value || '').trim();
            if (!val) { showStatus('Enter text to add'); return; }
            const cx = player.x + player.width + 20;
            const cy = player.y;
            addTextAt(cx, cy, val);
            textInput.value = '';
            saveCurrentLevel();
        });

        bindButtonAction(toggleHitboxBtn, () => {
            showHitboxes = !showHitboxes;
            toggleHitboxBtn.textContent = showHitboxes ? 'Hide Hitboxes' : 'Show Hitboxes';
        });

        // (collection feature removed) 

        bindButtonAction(startBtn, () => {
            startBtn.classList.add('animated');
            setTimeout(() => {
                startBtn.classList.remove('animated');
            }, 1000);
            showTitleScreen = false;
            isRunning = true;
        });

        bindButtonAction(editorBtn, () => {
            showTitleScreen = false;
            editorMode = !editorMode;
            editorBtn.textContent = editorMode ? 'Exit Editor' : 'Enter Editor';
            // pause when entering editor
            isRunning = !editorMode && isRunning;
            // enable/disable text controls while in editor
            if (textInput) textInput.disabled = !editorMode;
            if (addTextBtn) addTextBtn.disabled = !editorMode;
            // show/hide editor tools
            if (editorTools) editorTools.style.display = editorMode ? 'block' : 'none';
            // reset selected block
            selectedBlockIndex = -1;
        });

        // Editor tool buttons
        const buildModeBtn = document.getElementById('buildModeBtn');
        const editModeBtn = document.getElementById('editModeBtn');
        const deleteModeBtn = document.getElementById('deleteModeBtn');

        function setEditorToolMode(mode) {
            editorToolMode = mode;
            if (buildModeBtn) buildModeBtn.style.fontWeight = mode === 'build' ? 'bold' : 'normal';
            if (editModeBtn) editModeBtn.style.fontWeight = mode === 'edit' ? 'bold' : 'normal';
            if (deleteModeBtn) deleteModeBtn.style.fontWeight = mode === 'delete' ? 'bold' : 'normal';
            selectedBlockIndex = -1;
        }

        bindButtonAction(buildModeBtn, () => setEditorToolMode('build'));
        bindButtonAction(editModeBtn, () => setEditorToolMode('edit'));
        bindButtonAction(deleteModeBtn, () => setEditorToolMode('delete'));

        bindButtonAction(clearBtn, () => { blocks = []; });

        bindButtonAction(saveBtn, () => {
            // Save into collection and also into a single-slot local key for quick load
            try { saveCurrentLevel(); } catch (e) {}
            try { localStorage.setItem('platformer_level', JSON.stringify({ blocks: blocks, texts: texts, name: (levels[currentLevelIndex]||{}).name || '' })); } catch (e) {}
            showStatus('Level saved');
        });

        bindButtonAction(loadBtn, () => {
            const data = localStorage.getItem('platformer_level');
            if (!data) { showStatus('No saved level in localStorage'); return; }
            try {
                const payload = JSON.parse(data);
                blocks = payload.blocks || [];
                texts = payload.texts || [];
                if (!levels[currentLevelIndex]) levels[currentLevelIndex] = { name: payload.name || ('Level ' + (currentLevelIndex+1)), blocks: [], texts: [] };
                levels[currentLevelIndex].blocks = JSON.parse(JSON.stringify(blocks));
                levels[currentLevelIndex].texts = JSON.parse(JSON.stringify(texts));
                populateLevelSelect();
                loadLevel(currentLevelIndex);
                showStatus('Level loaded from localStorage');
            } catch (e) { showStatus('Failed to load level'); }
        });

        bindButtonAction(nextLevelBtn, () => { if (currentLevelIndex < levels.length - 1) loadLevel(currentLevelIndex + 1); else showStatus('No next level available'); });

        bindButtonAction(restartBtn, () => { loadLevel(currentLevelIndex); });

        function onPlayerKilled() {
            // Respawn at the start block (if present) or default start position
            const start = blocks.find(b => b.type === 'start');
            if (start) {
                player.x = start.x + Math.floor((start.width - player.width) / 2);
                player.y = start.y - player.height - 10000;
            } else {
                player.x = Math.floor(SCREEN_WIDTH/2) - Math.floor(player.width/2);
                player.y = SCREEN_HEIGHT - player.height - 100;
            }
            player.lateral_speed = 0;
            player.vertical_speed = 0;
            isRunning = true;
        }

        function onLevelComplete() {
            if (levelCompleted) return;
            levelCompleted = true;
            isRunning = false;
            showStatus('You have completed the level!');
            // do not auto-advance; user can click Next Level
        }

    </script>
</body>

</html>